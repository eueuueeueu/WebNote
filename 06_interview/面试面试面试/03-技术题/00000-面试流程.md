# 面试流程

> 面试官你好，我叫董浩，计算机科学与技术专业，我比较熟悉**Vue3**开发，结合**TS**写代码让程序更少出错，比如用**Pinia**管理全局数据（比如用户登录状态），用**Vue-Router**控制页面权限。会用**Vite**快速搭建项目，优化打包速度，比如之前有个项目用Webpack要等1分钟，换成Vite后10秒就能跑起来。样式方面，除了传统的**CSS/Less/Sass**，我最近在用**TailwindCSS**，像搭积木一样快速拼出页面，而且电脑手机都能适配。去年我做了个大屏的数据可视化项目，主要做了**动态图表**和**大屏适配**这方面。用**Git**管理代码，和同事合作时很少出冲突，代码注释也写得清楚。封装过**公共组件**，比如基于**Ant Design**改写过更符合业务需求的表格组件，团队里其他人都能直接用，省了很多重复劳动。遇到问题会查文档、看GitHub案例，比如之前用**VueUse**里的工具函数快速实现了拖拽排序功能。我对前端技术挺有热情的，平时也喜欢看一些博客论坛来了解前端的一些前沿的技术，希望可以加入贵公司。

> 面试官你好，我叫董浩，计算机科学与技术专业，目前有近一年的工作经验，在上一家公司主要做过后台管理系统，小程序的项目，我的技术主要有vue全家桶包括vueRouter、pinia，react、redux，在样式方面，除了传统的css/less/sass，我最近在用 tailwindcss，开发的速度更好，打包后的体积更小，在构建工具方面，使vite相比于webpack打包响应的速度更快，我还熟悉TS开发让程序更少出错，在项目方面，做过一个vue的用于生产执行管理的项目和一个react的一秒快送管理系统，在做项目的过程中，我封装了一些公共组件，团队里的其他成员也能够直接使用，省了很多的重复劳动，我平时喜欢看一些博客论坛来了解前端的一些前沿技术，希望可以加入到贵公司，谢谢

## 介绍一个你最近做的一个项目

项目描述：基于什么做的东西，有什么模块，各个模块做了什么，有什么收获和心得？

### 花山生产执行管理系统

> `描述`：这是一个为了解决传统工厂生产流程中存在的信息化程度低、数据孤岛、人工协同效率差等问题而研发的一个面向制造业工厂的生产执行管理系统，主要用到的技术有Vue、Vue-Router、Pinia、axios、Ant Design、Vxe UI、echarts、Lodash等。我主要负责的模块包括生产进度模块，负责实时跟踪产线进度，通过甘特图（echarts实现）可视化排产计划；供应商模块：整合客户/供应商管理，实现订单全链路追踪，工作站模块：标准化设备操作流程，降低生产异常率，生产领料模块：数字化领料流程，减少物料浪费。
>
> `主要的亮点`：采用Vue3组合式API+Pinia状态管理，实现响应式数据流；基于Ant Design Vue和Vxe UI二次封装可复用的业务组件如查询栏，操作栏，通过<KeepAlive>缓存高频切换组件，使用computed计算属性缓存计算的结果，使用防抖/节流避免高频触发事件；通过axios拦截器统一处理Token鉴权及API错误兜底，使用Lodash优化大数据量操作性能，解决供应商列表万级数据渲染卡顿问题
>
> `收获`：掌握了从0到1搭建中后台系统的完整链路，特别在复杂状态管理（如跨模块数据联动）方面积累了实战经验，通过组件封装推动团队规范化开发，深刻理解高复用性架构设计的重要性



### 德吉一秒快送管理系统

> 该项目是一个基于React技术栈的后台管理系统。这个项目主要用UmiJS+Redux搭建，配合AntDesign快速实现管理端的常见需求。我负责的主要包含六个核心模块：订单列表实时展示配送状态，骑手管理模块处理人员调度，计价规则模块支持动态配送费计算，还有财务提现、货物重量分类和优惠券运营模块。
>
> 在开发过程中，我特别注重工程化实践。比如通过二次封装表格组件，把分页逻辑和筛选条件处理抽象成高阶组件，使同样功能的页面代码量减少40%。针对全局状态管理，用Redux配合Immer处理高频更新的数据，同时用useRequest统一管理请求loading和错误状态。
>
> 印象比较深的是性能优化环节，在订单列表页用useMemo缓存筛选计算，配合虚拟滚动将万级数据渲染时间从3秒优化到800毫秒左右。这个项目让我对复杂状态下的组件更新机制有了更深理解，也积累了从零搭建企业级前端架构的经验。
>
> 您想了解哪个模块的具体实现细节？我可以展开说明。

`你提到的订单列表这个模块我比较感兴趣，你能展开说说吗?`

> 订单列表这个模块主要的功能包括：实时展示订单状态（待接单→配送中→已完成），对订单进行条件查询，对订单的状态进行操作。
> 主要实现的方式是：
> 使用封装的`API`发起请求（基于axios拦截器自动携带token），对请求到的数据实现按需渲染
> 表格组件采用`ant`二次封装，通过props注入
> 对这些大量数据进行虚拟滚动加载

`关于大量的数据进行虚拟滚动加载，你是如何实现的？`

> 在大规模列表数据时，会出现内存占用过大，页面卡顿，交互延迟甚至崩溃的现象，所以需要对这方面进行优化，按需渲染可见区域的内容，假设列表有 10,000 条数据，传统渲染会生成 10,000 个 DOM 节点。虚拟滚动加载通过实时监听用户的滚动事件，计算可视区域的位置，只渲染「可视区+缓冲区的DOM节点」。
> 具体实现：React-window
>
> ```jsx
> import { FixedSizeList } from 'react-window';
> /** 
>   * 每个列表项的组件
>   * @param index：列表项的下标；style：列表项的样式（此参数必须传入列表项的组件中，否则会出现滚动到下方出现空白的情况）
> **/ 
> const Row = ({ index, style }) => (
>   <div style={style}>Row {index}</div>
> );
>  
> const Example = () => (
>   <FixedSizeList
>     height={150} // 列表可视区域的高度
>     itemCount={1000} // 列表数据长度
>     itemSize={35} // 列表行高
>     width={300} //列表可视区域的宽度
>   >
>     {Row}
>   </FixedSizeList>
> );
> ```

`你提到的骑手管理这个模块我比较感兴趣，你能展开说说吗?`

> 骑手管理这个模块主要的功能包括：展示骑手的信息和状态，对订单进行条件查询，对订单的状态进行操作。
> 主要实现的方式是：
> 使用封装的`API`发起请求（基于axios拦截器自动携带token），对请求到的数据实现按需渲染
> 表格组件采用`ant`二次封装，通过props注入
> 对这些大量数据进行虚拟滚动加载







## 76、前端如何实现大文件上传

> **前端处理大文件上传的最佳实践包括：分块上传、进度显示、断点续传、优化用户体验。** 其中，**分块上传**是最常用且有效的方法之一，这种方法不仅能有效减少单个请求的大小，还可以提高上传的稳定性，避免因为网络波动导致整个文件上传失败。
>
> 分块上传的核心在于将大文件按一定大小分割成多个小块，并逐块上传到服务器。服务器端会将这些小块重新组装成完整的文件。具体的步骤就是
>
> 1. 将大文件按设定的块大小分割成多个小块
> 2. 依次上传每个分块，上传时可以带上块序号和文件唯一标识
> 3. 服务器接收到分块后，保存并记录块序号，待所有分块上传完成后，进行合并
>
> **断点续传**：
>
> - 记录已上传分块索引（`uploadedChunks`）
> - 重新上传时跳过已上传分块
> - 页面刷新后需要重新选择文件（可扩展本地存储）
>
> **秒传功能**：
>
> - 发送文件哈希到服务端检查
> - 文件存在时直接返回成功
>
> **进度展示**：
>
> - 实时显示每个分块的上传进度
> - 计算并显示整体上传进度



# 第一次模拟面试的项目介绍

## 1、你做的项目中，挑几个项目做一个项目介绍？



## 2、如何理解HTML5的语义化标签？

> HTML5语义化标签通过引入具有明确含义的元素，使得网页结构更清晰、更易于理解和维护。
>
> 常见语义化标签
>
> - `<header>`：页眉，通常包含标题和导航。
> - `<footer>`：页脚，包含版权、联系方式等。
> - `<nav>`：主导航链接。
> - `<main>`：页面主要内容，唯一存在。
> - `<article>`：独立内容块（如博客文章）。
> - `<section>`：内容分区（如章节）。
> - `<aside>`：侧边栏或附加内容。
>
> 优势：
>
> **SEO优化**：搜索引擎更易抓取关键内容，**代码可读性**：结构清晰，便于团队协作和维护。

## 3、在你的项目中有没有遇到一些用到闭包的场景？闭包的优点和缺点是啥？

> 场景：比如模块化开发，对私有变量进行封装；函数柯里化；防抖和节流
>
> 优点：数据私有化、状态持久化、支持高阶函数、柯里化等函数式编程范式、避免全局污染、提升代码可维护性
>
> 缺点：内存泄漏风险、性能损耗
>
> - 闭包会保留整个作用域链，内存占用较高。
> - 避免在频繁调用的函数（如渲染循环）中创建闭包。

## 4、那你平时在使用闭包的时候是怎么样避免内存泄漏的？

> 及时销毁闭包依赖的外部引用，在vue中使用onBeforeUnmount在组件卸载之前对这些引用关系进行去引用，在react中使用useEffect，通过返回值函数；来清理闭包中的标记

## 5、看到你的简历中提到对es6的了解，在没有ES6的class之前，我们是如何去实现继承的？

> 在 ES6 的 `class` 出现之前，JavaScript 通过`原型链` 和 `构造函数`模拟继承。具体实现方式：
> **原型链继承**：直接把子类的原型对象（`prototype`）指向父类的实例，这样所有子类实例都能通过原型链访问父类的属性和方法。
>
> - **问题**：
>   如果父类属性是 ​**​引用类型（如数组、对象）​**​，所有子类实例会共享同一份数据，修改一个实例会影响其他实例。
>
> **借用构造函数继承**：在子类的构造函数中，通过 `Parent.call(this)` 调用父类构造函数，让每个子类实例拥有独立的属性副本。
>
> - **改进点**：
>   解决了引用类型数据共享的问题，且支持向父类构造函数传参。
> - **新问题**：
>   父类原型上定义的方法无法被子类继承，导致方法无法复用（所有方法必须写在构造函数中）。
>
> **组合继承**：
>
> 1. **属性继承**：在子类构造函数中调用父类构造函数（`Parent.call(this)`），保证属性独立。
> 2. **方法继承**：将子类的原型指向父类的实例（`Child.prototype = new Parent()`），继承原型方法。
> 3. **问题**：
>    父类构造函数被调用了两次（一次在子类构造函数中，一次在原型赋值时），导致子类原型对象上存在冗余的父类属性。
>
> **寄生组合继承**：
>
> 1. **属性继承**：子类构造函数中调用父类构造函数（`Parent.call(this)`）。
> 2. **方法继承**：通过 `Object.create()` 创建一个空对象，其原型指向父类的原型对象，再将这个空对象作为子类的原型。
>
> - 避免了调用两次父类构造函数。
> - 子类原型链干净，仅继承父类原型上的方法。

回答：

> 最初用原型链继承，但引用类型数据会共享；后来引入借用构造函数，解决了数据独立但无法复用方法；
> 组合继承结合了两者，但父类构造函数被调用两次；最终通过寄生组合继承，用 `Object.create()` 创建中间原型对象，实现高效继承。
> 而 ES6 的 `class` 继承语法，底层仍然是寄生组合继承的封装。

## 6、那你觉得class语法和你刚刚说的寄生组合式继承，有没有什么优劣可以对比？ES6的class有什么优势，有什么劣势

> ES6 的 `class` 语法与寄生组合式继承本质上是同一套继承机制的 **不同表达方式**，但两者在设计理念和使用体验上有显著差异。
>
> 优势：
> class的本质是一个语法糖，语法比较简洁直观，对比寄生组合继承的代码量更少
>
> class语法中子类构造函数必须先调用 `super()`，否则报错，无需手动设置 `Child.prototype.constructor`，自然处理原型链
>
> 劣势：
> 无法完全脱离原型链思维，本质上还是一个构造函数
>
> 私有字段兼容性问题：\#count = 0; 兼容性不好，可以使用babel将es6代码转换为兼容性更好的es5
>
> 无法直接实现混合继承（Mixin）
>
> ```js
> // 寄生组合继承可灵活组合多个对象
> function mixin(Base, ...mixins) {
>   return mixins.reduce((cls, mixin) => mixin(cls), Base);
> }
> 
> // ES6 Class 需通过变通方式实现
> class MyClass extends mixin(BaseClass, Mixin1, Mixin2) {}
> ```

## 7、你在简历中多次提到了优化页面的性能，你能具体说一下你做了哪些优化？

### (1).首屏加载优化

> 1.把非公司核心业务代码之外的其他库、框架、ui组件、图标等作cdn加速。
> 2.查看网络面板中是否存在请求过大的静态资源，如果存在我们需要使用异步加载的语法对其拆分，充分利用浏览的并发下载提高静态资源的下载速度，从而提升首屏加载速度。
> 3.对公司核心业务代码gzip压缩发送给浏览器，由浏览器解压缩后解析。
> 4.最后使用loading图或骨架屏缓解用户的等待焦虑。

### (2).交互流畅性优化

> 虚拟滚动：采用 `react-window` 实现虚拟列表，仅渲染可视区域+缓冲区
>
> Web Worker 数据处理：将大数据排序/过滤逻辑迁移至 Worker 线程
>
> 防抖和节流：搜索框输入使用 `lodash.debounce` 延迟触发查询（300ms），减少冗余请求

### (3).代码分隔和懒加载

> 使用 `React.lazy` + `Suspense` 分割非首屏模块（如用户评价、推荐商品）。
>
> 路由级动态导入：
> ```js
> const ProductDetail = lazy(() => import('./pages/ProductDetail'));
> ```

### (4).Keep-alive缓存组件实例

> 对于一下不活动的复杂的表单和包含大量数据的列表组件，可以使用keep-alive缓存避免重复创建和销毁组件，从而提高应用的性能和用户体验。

### (5)React中对组件渲染的性能优化

> 在类组件中使用`shouldComponentUpdate`类来自定义是否渲染的逻辑
>
> 对于props不发生变化,不需要更新的子组件，使用react.memo包裹来避免重渲染
>
> 对于一些传入子组件的计算结果或函数，可以使用usememo和usecallback来缓存计算的结果和函数的结果

## 8、我对你说的那个列表的按需加载（虚拟滚动）很感兴趣，他怎么做到的？

> 虚拟滚动的核心原理是 **仅渲染 可视区域 + 缓冲区**，通过动态计算和位置偏移模拟完整列表的滚动效果
>
> react生态库：
>
> 1.**react-window**（轻量级首选）：是高效渲染大型列表和表格数据的 React 组件库，使用时，需定义容器尺寸（`height`/`width`）、数据总量（`itemCount`）及单条数据高度（`itemSize`），通过渲染函数（如 `Row`）返回每项内容，库内部自动计算项的位置偏移（`style.top`）并复用 DOM 节点，从而在万级数据场景下保持流畅滚动。
>
> ```js
> import { VariableSizeList as List } from 'react-window';
> 
> // 缓存每项高度测量结果
> const sizeMap = {};
> const setItemSize = (index, size) => {
>   sizeMap[index] = size;
> };
> 
> // 动态获取项高度
> const getItemSize = index => sizeMap[index] || 80; // 默认高度 80px
> 
> const Row = ({ index, style }) => {
>   const [content] = useState(fetchComment(index)); // 加载评论内容
> 
>   return (
>     <div 
>       style={style}
>       ref={el => {
>         if (el) {
>           const height = el.getBoundingClientRect().height;
>           setItemSize(index, height); // 渲染后测量真实高度
>         }
>       }}
>     >
>       <div className="comment">{content.text}</div>
>       <div className="author">{content.author}</div>
>     </div>
>   );
> };
> 
> const CommentList = () => (
>   <List
>     height={600}
>     width={800}
>     itemCount={100000}
>     itemSize={getItemSize} // 动态高度函数
>     estimatedItemSize={80} // 预估高度（优化滚动条精度）
>   >
>     {Row}
>   </List>
> );
> ```
>
> 2.**react-virtualized**（功能全面）
>
> **React-Virtualized** 是一个支持复杂虚拟滚动的库，提供 `List`、`Grid` 等组件处理大规模数据渲染。使用时通过 `rowCount` 定义数据总量，`rowHeight` 设置行高（支持动态函数），`rowRenderer` 函数返回每行内容，结合 `AutoSizer` 自动适配容器尺寸（如 `<AutoSizer>{({width, height}) => <List {...{width, height}}/>}</AutoSizer>`），动态计算并渲染可视区域项，适用于多列表格、动态高度等复杂场景。
>
> 
>
> 3.**总结**：在 React 项目中，我会优先选择 **react-window**，因为它更轻量（仅 5KB）且维护活跃，适合处理简单列表或固定高度场景，其 API 更简洁（如 `FixedSizeList` 一行配置即可实现基础虚拟滚动）。而 **react-virtualized** 虽然功能更全面（支持动态表格、网格和复杂布局），但体积较大（约 35KB）且已停止新功能开发，仅在需要多列动态高度表格或树形结构等复杂需求时才会考虑。例如，在电商后台渲染纯商品列表时，react-window 的 `VariableSizeList` 配合尺寸缓存即可满足需求，无需引入冗余功能。
>
> 
>
> Vue生态库：
>
> 1.**vue-virtual-scroller**（官方推荐）
>
> **vue-virtual-scroller** 是 Vue 生态中实现虚拟滚动的核心库，通过 `<RecycleScroller>` 组件动态渲染可视项。使用时，绑定数据源 `items`，定义 `item-size`（固定高度）或 `min-item-size`（动态高度基准值），在 `item` 插槽中编写模板，库内部根据滚动位置自动计算并复用可见项的 DOM 节点，例如：
>
> ```vue
> <template>
>   <RecycleScroller 
>     :items="items" 
>     :item-size="60" 
>     key-field="id"
>   >
>     <template #default="{ item }">
>       <div class="item">{{ item.content }}</div>
>     </template>
>   </RecycleScroller>
> </template>
> ```
>
> 2.**vue-virtual-scroll-list**(轻量级 )
>
> **vue-virtual-scroll-list** 是轻量级 Vue 虚拟滚动库，通过 `<virtual-list>` 组件实现。使用时绑定数据源 `:data` 并定义固定的项目尺寸 `:size`（如 `50`）及预留渲染项数 `:remain`（如 `20`），在模板中遍历当前可视项，例如：
>
> ```vue
> <template>
>   <virtual-list 
>     :size="50" 
>     :remain="20" 
>     :data="items"
>   >
>     <template #default="{ item }">
>       <div class="item">{{ item.text }}</div>
>     </template>
>   </virtual-list>
> </template>
> ```
>
> 3.**总结**：我会优先选择 **vue-virtual-scroller**（由 Vue 核心团队维护），因其支持动态尺寸、滚动位置恢复和更精细的 DOM 复用（如 `<RecycleScroller>` 组件），适合需要动态高度项或复杂交互的场景（如聊天消息流）。而 **vue-virtual-scroll-list** 更轻量（仅 3KB），API 极简（如 `<virtual-list :size="50" :remain="20">`），适合固定高度的简单列表（如纯文本展示），尤其在需要兼容 Vue 2/3 的旧项目时更易集成。例如，在渲染动态高度评论时选前者，固定高度的通知列表则用后者。

### 9、按照你这样说，如果我滚动的速度特别快，有没有可能他来不及加载？你如何解决这个问题，还是说你刚刚提到的那个库(react-window)它已经解决了呢？

> 主流的虚拟滚动库（如 `react-window`、`vue-virtual-scroller`）已通过 **预渲染缓冲（Overscan）** 机制解决了极速滚动空白问题，即在可视区域外额外渲染一定数量的隐藏项（如上/下各预加载 5-10 项），配合 **滚动事件节流** 和 **异步批量渲染**，使得即使以每秒千级像素的极速滚动（远超人类操作极限），也能无缝衔接渲染内容。对于一些极端情况，也可以通过数据分块加载 + 骨架屏占位来优化用户的体验。

### 10、你刚刚在vue的性能优化手段中提到了keep-alive，keep-alive有哪些属性可以让我们去做组件的缓存？

> `<keep-alive>` 组件通过 **`include`**（指定缓存的白名单）、**`exclude`**（排除缓存的名单）和 **`max`**（限制最大缓存实例数，溢出时销毁最久未访问的组件）三个属性控制缓存规则。例如 `<keep-alive :include="['Home', 'User']" :max="10">` 会缓存 `Home` 和 `User` 组件，最多保留 10 个实例，避免内存泄漏。需配合组件的 `name` 选项生效，常用于路由页面或动态组件的状态保活。

### 11、那react中没有提供keep-alive对吧，那你有没有办法去实现一个keep-alive，实现路由组件的缓存

> 





















































